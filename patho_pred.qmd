---
title: "Pathology prediction in rowers"
author: "FÃ©lix BOUDRY"
---

## Context

This analysis aim at detecting pathological athletes during an altitude training camp. To do so we used urine sample analysed by NMR. Here we try different models to detect the pathological samples to determine which one is the best.

```{r}
#| label: config
#| include: false
#| fig-align: center
set.seed(42)
library(tidyverse)
library(data.table)
library(knitr)
library(janitor)
library(psych)
library(kableExtra)
library(caret)
library(pls)
library(vip)
library(factoextra)
library(cluster)
library(ggfortify)
library(magrittr)
library(cvms)
library(ggpubr)
library(reshape2)
library(KODAMA)
library(ggimage)
library(rsvg)
source("functions.R")

theme_set(new = theme_bw()) # ggplot theme
```

# Import and pre-processing

Pre-processing was done using [npflow](https://nmrprocflow.org). This pre-processing is based on the [Rnmr1D](https://cran.r-project.org/web/packages/Rnmr1D/index.html) package.

```{r}
#| label: import & pre-processing
antrop_data <- fread(input = "Data/subjects.csv") |>
  clean_names() |>
  select(c("age", "height", "weight"))
categories <- c("patho", "day", "Samplecode", "name", "surname", "discriminant", "date", "quality", "pathology_during")
data <- fread("Data/data.csv") |>
  mutate(across(-any_of(categories), ~ ReplaceMissingByLoD(int.mat = .x))) |>
  mutate(across(-any_of(categories), ~ scale(.x))) |>
  merge(fread("Data/samples.csv"), by = "Samplecode") |>
  replace_na(list(patho = 0, pathology_during = 0)) |>
  column_to_rownames(var = "Samplecode") |>
  mutate(patho = as.factor(patho))

# Define subsets datasets
condition_patho <- quo(patho == "1" & row_number() == min(which(patho == "1")))
condition_first <- quo(day == min(day) & pathology_during == "1")
condition_pre <- quo(lead(patho == "1" & row_number() == min(which(patho == "1"))))
condition_last <- quo(day == max(day) & pathology_during != "1")

data_first_patho <- data |>
  arrange(day) |>
  filter(!!condition_patho | !!condition_first, .by = c(name, surname)) |>
  suppressWarnings()

data_pre_patho <- data |>
  arrange(day) |>
  filter(!!condition_patho | !!condition_pre, .by = c(name, surname)) |>
  suppressWarnings()

data_last_patho <- data |>
  arrange(day) |>
  filter(!!condition_patho | !!condition_last, .by = c(name, surname)) |>
  suppressWarnings()

# Combine subsets into a list
data_sub <- list(
  data_first_patho = data_first_patho,
  data_pre_patho = data_pre_patho,
  data_last_patho = data_last_patho
)

# Test set
test <- data |>
  group_by(name, surname) |>
  arrange(day) |>
  mutate(next_after_patho = lag(patho, default = "0") == "1") |>
  filter(day == "3" | patho == "1" | next_after_patho) |>
  ungroup() |>
  select(-next_after_patho)
```

# Data description

```{r}
#| label: data-description
# Subject description
describe(x = antrop_data, na.rm = TRUE) |>
  round(digits = 0) |>
  select(c("mean", "sd", "median", "min", "max")) |>
  kable(
    caption = paste0("Anthropological values (n = ", nrow(x = antrop_data), ")"),
    table.attr = 'data-quarto-disable-processing="true"'
  ) |>
  kable_styling(
    bootstrap_options = c("striped"),
    full_width = FALSE
  )
# PCA on full dataset
pca_res <- prcomp(x = select(.data = data, -any_of(categories)))
autoplot(
  object = pca_res,
  data = select(.data = data, -any_of(categories)),
  loadings.label.size = 3
) +
  geom_point(
    mapping = aes(color = data$patho),
    size = 2
  ) +
  geom_text(mapping = aes(label = rownames(data)), vjust = 0, hjust = 0) +
  stat_ellipse(mapping = aes(group = data$patho, color = data$patho)) +
  labs(color = "Patho")

# Buckets correlations
corr_matrix <- cor(select(data, -any_of(categories)), method = "pearson") |>
  as.matrix() |>
  melt()
ggplot(corr_matrix, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_x_discrete(breaks = levels(corr_matrix$Var2)[c(T, rep(F, 14))]) +
  scale_y_discrete(breaks = levels(corr_matrix$Var1)[c(T, rep(F, 14))]) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(title = "Spectral Data Correlation Heatmap", x = "Chemical Shift (buckets)", y = "Chemical Shift (buckets)")
```

# k-means

```{r}
#| label: km-pp
#| fig-align: center
lapply(data_sub, \(x) {
  # KM computation
  patho <- x$patho
  km_res <- kmeans(
    x = select(.data = x, -any_of(categories)),
    centers = 2L,
    nstart = 25L
  )
  km_cluster <- km_res$cluster - 1
  
  # KM plot
  km_fig <- fviz_cluster(
    object = km_res,
    data = select(.data = x, -any_of(categories)),
    geom = "none",
    shape = NULL
  ) +
    geom_point(
      mapping = aes(shape = patho),
      size = 2
    ) +
    labs(shape = "Status")

  # Confusion matrix
  km_cluster <- km_res$cluster - 1
  conf_mat_plot <- confusion_matrix(targets = x$patho, predictions = km_cluster) |>
    plot_confusion_matrix()
  conf_mat <- confusionMatrix(data = as.factor(x = km_cluster), as.factor(x = x$patho))
  return(lst(km_fig, conf_mat_plot, conf_mat))
})
```

# Hierarchical clustering

```{r}
#| label: hc-pp
#| fig-align: center
lapply(data_sub, \(x) {
  # HC computation
  hc_res <- agnes(x = select(.data = x, -any_of(categories)), method = "ward")

  # HC plot
  hc_plot <- hclust_ggplot(clust_data = hc_res, dataset = x)

  # Confusion matrix
  conf_mat_plot <- confusion_matrix(
    targets = x$patho,
    predictions = hc_res |> cutree(k = 2L) |> subtract(e1 = 1)
  ) |>
    plot_confusion_matrix()
  conf_mat <- confusionMatrix(
    data = hc_res |> cutree(k = 2L) |> subtract(e1 = 1) |> as.factor(),
    x$patho |> as.factor()
  )
  return(lst(hc_plot, conf_mat_plot, conf_mat))
})
```

# PCA

```{r}
#| label: pca-pp
#| fig-align: center
lapply(data_sub, \(x) {
  # PCA computation
  pca_res <- prcomp(x = select(.data = x, -any_of(categories)))

  # PCA plot
  pca_plot <- autoplot(
    object = pca_res,
    data = select(.data = x, -any_of(categories)),
    loadings.label.size = 3
  ) +
    geom_point(
      mapping = aes(color = x$patho),
      size = 2
    ) +
    stat_ellipse(mapping = aes(group = x$patho, color = x$patho)) +
    labs(color = "Patho")
  loadings_plot <- fviz_pca_var(pca_res, select.var = list(contrib = 30), col.var = "contrib")
  return(lst(pca_plot, loadings_plot))
})
```

# PLS-DA

```{r}
#| label: plsda-pp
#| fig-align: center
lapply(data_sub, \(x) {
  # PLSDA computation
  pls_res <- caret::plsda(
    x = select(.data = x, -any_of(categories)),
    as.factor(x = x$patho),
    ncomp = 5,
    validation = "CV"
  )

  # Prepare scores data frame
  scores <- pls_res$scores[, c(1, 2)]
  scores_df <- as.data.frame(scores) |>
    mutate(Class = as.factor(x$patho)) # Add class labels for coloring

  # PLSDA plot
  pls_plot <- ggplot(scores_df, aes(x = `Comp 1`, y = `Comp 2`, color = Class)) +
    geom_point(size = 3) +
    stat_ellipse() +
    labs(
      title = "PLS-DA Score Plot",
      x = "Component 1",
      y = "Component 2"
    )

  # VIP
  my_vips <- vip(object = pls_res, metric = "rmse")
  vip_plot <- autoplot(my_vips)
  plot_data <- x |>
    select(c("patho", my_vips$data$Variable)) |>
    pivot_longer(
      cols = starts_with(match = "B"),
      names_to = "Buckets",
      values_to = "Value"
    )
  buckets_stats <- lapply(
    my_vips$data$Variable,
    \(z) wilcox.test(x[x$patho == "1", z], x[x$patho == "0", z])$p.value
  ) |>
    `names<-`(my_vips$data$Variable) |>
    lapply(p.adjust, method = "BH")
  stat_plot <- ggplot(
    data = plot_data,
    mapping = aes(x = Buckets, y = Value, fill = patho)
  ) +
    geom_boxplot() +
    stat_compare_means(mapping = aes(group = patho), label = "p.signif") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  # Confusion matrix
  conf_mat_plot <- predict(
    object = pls_res,
    newdata = select(.data = test, -any_of(categories))
  ) |>
    as.factor() |>
    confusion_matrix(targets = test$patho |> as.factor()) |>
    plot_confusion_matrix()
  conf_mat <- predict(
    object = pls_res,
    newdata = select(.data = test, -any_of(categories))
  ) |>
    as.factor() |>
    confusionMatrix(data = test$patho |> as.factor())

  # Validation metrics
  valid_metrics <- pls.double.cv(select(.data = x, -any_of(categories)), as.factor(x = x$patho), scaling = NULL, times = 10, runn = 10)[c("R2Y", "Q2Y")]
  return(lst(pls_plot, vip_plot, stat_plot, conf_mat_plot, conf_mat, valid_metrics))
})
```

